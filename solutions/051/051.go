package euler051

import (
	"fmt"

	"github.com/phensley/go-euler"
)

var (
	zeroToNine = []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
)

func init() {
	euler.Register("051", "Prime digit replacements", solve)
}

func solve(ctx *euler.Context) {
	s := newSolution()
	answer := s.solve()
	ctx.SetAnswer(answer)
}

func (s *solution) solve() string {

	// TODO: generalize to any number of digits. For now we found
	// that slots=3 digits=6 produces the right answer.

	digits := 6

	// Prime family size
	size := 8

	// Known good patterns for 6-digit number, 3 replacement slots
	patterns := makePatterns(3, 6)

	// We use a bitstring of primes up to 6 digits, since it enables
	// (a) scanning for likely primes in ascending order, stopping
	// on the first match, and (b) fast primality checking.  Generating
	// the primes ends up being pretty fast (10 ms) up to 6 digits.

	for _, n := range s.primes {
		d := int(euler.NumDigitsBase10(n))
		if d < digits {
			continue
		}

		r := s.check(int(n), size, patterns)
		if r != -1 {
			return fmt.Sprintf("%d", r)
		}
	}
	return ""
}

func makePatterns(slots, size int) [][]int {
	// Create a seed pattern of given size, populated with '1'
	// but leave some slots '0'
	seed := make([]int, size)
	for i := slots; i < size; i++ {
		seed[i] = 1
	}

	// Generate permutations of the seed pattern
	res := [][]int{}
	perms := euler.NewPermutations(seed)
	for perms.Next() {
		p := perms.Get()
		r := make([]int, len(p))
		copy(r, p)
		res = append(res, r)
	}
	return res
}

type solution struct {
	primeset *euler.Bitstring
	primes   []uint64
}

func newSolution() *solution {
	primeset := euler.PrimesSieveOfAtkin(1000000)
	return &solution{primeset, primeset.Ones()}
}

func (s *solution) check(n, target int, patterns [][]int) int {
	// Detect short counts to break out early
	lim := 10 - target

	// Check candidate family generated by applying each of the patterns to N
	for _, p := range patterns {

		// Capture the first prime in the potential family.
		first := -1

		// Count number of primes in the family
		count := 0

		// Swap in digits 0-9 for each 0 in the pattern. Where the
		// slot is a 1, leave the original digit.
		for pos, d := range zeroToNine {
			// Increasing factor to switch to the next higher digit
			f := 1

			// Construct new number by replacing digits in N using the current pattern
			x := 0

			// Avoid setting leading digits to zero
			if x == 0 && d == 0 {
				continue
			}

			// Replace digits using the pattern mask
			for i := len(p) - 1; i >= 0; i-- {
				if p[i] == 0 {
					x += d * f
				} else {
					x += (n % (f * 10)) - (n % f)
				}
				f *= 10
			}

			// If candidate is prime, we found a member of a family.
			if s.primeset.IsSet(uint64(x)) {
				if first == -1 {
					first = x
				}
				count++

				// When we reach the family size target, return the first member in
				// the family as the answer.
				if count == target {
					return first
				}
			}

			// Break out when it appears impossible to reach target.
			if pos >= lim && count < (pos-lim) {
				break
			}

		}
	}

	// Nothing reached out threshold.
	return -1
}
